/*
  Sketch generated by the Arduino IoT Cloud Thing "ESP32_CAN"
  https://create.arduino.cc/cloud/things/006040eb-35ad-4e64-9a71-79b5338e6b62

  Arduino IoT Cloud Variables description

  The following variables are automatically generated and updated when changes are made to the Thing

  float setPoint_rx;
  int newSetPoint_tx;

  Variables which are marked as READ/WRITE in the Cloud Thing will also have functions
  which are called when their values are changed from the Dashboard.
  These functions are generated with the Thing and added at the end of this sketch.
*/

#include "thingProperties.h"
#include <mcp_can.h>
#include <SPI.h>

long unsigned int rxId;
unsigned char len = 0;
unsigned char rxBuf[8];
int ss_setpoint;
uint8_t data[8]={0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};


#define CAN0_INT 4                              // Set INT to pin D2
MCP_CAN CAN0(15);  // Set CS to pin 10

void setup() {
  // Initialize serial and wait for port to open:
  Serial.begin(115200);
  // This delay gives the chance to wait for a Serial Monitor without blocking if none is found
  delay(1500);

  // Defined in thingProperties.h
  initProperties();

  // Connect to Arduino IoT Cloud
  ArduinoCloud.begin(ArduinoIoTPreferredConnection);
  
  // Initialize MCP2515 running at 16MHz with a baudrate of 500kb/s and the masks and filters disabled.
  if(CAN0.begin(MCP_ANY, CAN_1000KBPS, MCP_8MHZ) == CAN_OK)
    Serial.println("MCP2515 Initialized Successfully!");
  else
    Serial.println("Error Initializing MCP2515...");
  
  CAN0.setMode(MCP_NORMAL);                           // Set operation mode to normal so the MCP2515 sends acks to received data.

  pinMode(CAN0_INT, INPUT);                           // Configuring pin for /INT input
  
  Serial.println("MCP2515 Library Receive Example...");


  /*
     The following function allows you to obtain more information
     related to the state of network and IoT Cloud connection and errors
     the higher number the more granular information youâ€™ll get.
     The default is 0 (only errors).
     Maximum is 4
  */
  setDebugMessageLevel(2);
  ArduinoCloud.printDebugInfo();
}

void loop() {
  ArduinoCloud.update();
  // Your code here
  if(!digitalRead(CAN0_INT))                  // If CAN0_INT pin is low, read receive buffer
  {
    CAN0.readMsgBuf(&rxId, &len, rxBuf);      // Read data: len = data length, buf = data byte(s)
    
    if((rxId & 0x80000000) == 0x80000000)     // Determine if ID is standard (11 bits) or extended (29 bits)
      //sprintf(msgString, "Extended ID: 0x%.8lX  DLC: %1d  Data:", (rxId & 0x1FFFFFFF), len);
      Serial.println("Extended CAN: ");
    else
      //sprintf(msgString, "Standard ID: 0x%.3lX       DLC: %1d  Data:", rxId, len);
      Serial.print("Standard CAN: ");
  
    //Serial.print(msgString);
  
    if((rxId & 0x40000000) == 0x40000000)     // Determine if message is a remote request frame.
    {    
      Serial.print("REMOTE REQUEST FRAME");
      //Serial.print(msgString);
    } 
    else 
    {
      Serial.print("Data: ");
      Serial.println((uint8_t)rxBuf[0]);
      setPoint_rx = rxBuf[0]  * 100 / 255;
      //setPoint_rx = data[0];
    }
    
  }

}

/*
  Since SetPointTx is READ_WRITE variable, onTxDataChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onSetPointRxData()  {
  //data[0] = newSetPoint_tx;
  //Serial.print("Sp: ");
  //Serial.println(data[0]);
}

/*
  Since NewSetPointTx is READ_WRITE variable, onNewSetPointTxChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onNewSetPointTxChange()  {
  // Add your code here to act upon NewSetPointTx change
  data[0] = newSetPoint_tx;
  for (int i = 0; i < 20; i++) {
    byte sndStat = CAN0.sendMsgBuf(0x255, 0, 8, data);
    if(sndStat == CAN_OK){
      Serial.println("Message Sent Successfully!");
       Serial.println(data[0]);
    } else {
      Serial.println("Error Sending Message!");
    }
  }
}